<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>C++ Keywords | I0gan</title><meta name="keywords" content="c++"><meta name="author" content="i0gan"><meta name="copyright" content="i0gan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="Keywords of C++alignas(c++11)     &#x2F;&#x2F;声明结构体或类的对齐数 alignof(c++11)     &#x2F;&#x2F;查看结构体或类的对齐数 and                 &#x2F;&#x2F;等价于 &amp;&amp; and_eq             &#x2F;&#x2F;等价于 &amp;&amp;&#x3D; asm                 &#x2F;&#x2F;汇编语句 auto             &#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Keywords">
<meta property="og:url" content="http://blog.i0gan.cn/2020/02/22/c++-keywords/index.html">
<meta property="og:site_name" content="I0gan">
<meta property="og:description" content="Keywords of C++alignas(c++11)     &#x2F;&#x2F;声明结构体或类的对齐数 alignof(c++11)     &#x2F;&#x2F;查看结构体或类的对齐数 and                 &#x2F;&#x2F;等价于 &amp;&amp; and_eq             &#x2F;&#x2F;等价于 &amp;&amp;&#x3D; asm                 &#x2F;&#x2F;汇编语句 auto             &#x2F;">
<meta property="og:locale">
<meta property="og:image" content="http://blog.i0gan.cn/img/text_bg.jpg">
<meta property="article:published_time" content="2020-02-22T07:46:00.000Z">
<meta property="article:modified_time" content="2021-03-31T18:21:26.413Z">
<meta property="article:author" content="i0gan">
<meta property="article:tag" content="c++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://blog.i0gan.cn/img/text_bg.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://blog.i0gan.cn/2020/02/22/c++-keywords/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-04-01 02:21:26'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.2.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/header.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">61</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">28</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">23</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/text_bg.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">I0gan</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">C++ Keywords</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2020-02-22T07:46:00.000Z" title="Created 2020-02-22 15:46:00">2020-02-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-03-31T18:21:26.413Z" title="Updated 2021-04-01 02:21:26">2021-04-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/c/">c++</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Keywords-of-C"><a href="#Keywords-of-C" class="headerlink" title="Keywords of C++"></a>Keywords of C++</h2><pre><code>alignas(c++11)     //声明结构体或类的对齐数
alignof(c++11)     //查看结构体或类的对齐数
and                 //等价于 &amp;&amp;
and_eq             //等价于 &amp;&amp;=
asm                 //汇编语句
auto             //自动类型
bitand             //等价于  &amp;
bitor             //等价于　|
bool             //bool类型
break             //跳出当前循环,或switch
case             //结合switch使用
catch             //捕获异常
char             //1字节变量
short             //2字节变量
signed             //声明为有符号类型
unsigned         //声明为无符号类型
char16_t(c++11)  //常使用于Unicode字符
char32_t(c++11)     //常使用于Unicode字符
int                 //默认４字节
long             //不比int类型小的类型
class             //类,或者声明模板类型
compl             //等价于 ~
concept(概念Ts)     //专家级别使用
const             //声明常变量
constexpr(c++11) //用作函数时,是在编译是进行函数调用的,类似与宏
const_cast         //常变量强制转化为其他变量类型
continue         //结合循环来使用    
decltype(c++11)  //与auto差不多,可以用于某个不确定多个参数类型的模板函数
default             //结合switch来使用
delete             //释放new出来的东西
new                 //开辟内存
do                 //配合 while构成循环
explicit         //不能隐式构造
export             //专家级别使用...
extern             //改变某个变量的作用域,常用在不同文件中使用同一个变量
float             //4字节的浮点类型
double             //８字节的浮点类型
for                 //for循环
goto             //跳转
if                 //判断
friend             //给类中的一些函数使用,可以访问类中的私有成员变量
inline             //内联声明, 编译器对该函数进行优化,类中函数和模板函数默认代这个参数
mutable             //在lambda表达式中使用表示为传递进来的变量可以被赋值
namespace         //声明命名空间　
noexcept(c++11)  //声明为不抛出异常,利于编译器的优化 
not                 //等价与 !
not_eq             //等价于 !=
nullptr(c++11)     //c++11以后声明空指针类型,主要解决模板函数中的参数问题
operator         //操作运算重载
or                 //等价与 |
or_eq             //等价于 |=
private             //声明成员为私有的
public             //声明成员为公共的
protected         //声明成员为保护的
register         //声明在寄存器里的变量
reinterpret_cast //常用在　一个类型的指针转化为另一个类型的指针
requires(概念TS) //一个概念,目前还没有编译器实现
return     //函数的返回
static     //声明变量为静态的
sizeof     //获取某个变量的大小
static_assert(c++11) //静态断言, 常用
static_cast //静态转化
struct     //结构体类型
switch     //switch分支判断结构
template //声明模板
this     //this指针, 常用在class和struct
thread_local(c++11)  //结合线程来使用
throw     //抛出异常
true     //bool类型的真
false     //bool类型的假
try         //异常尝试
typedef     //改变变量名称
typeid     //获取类型的id号
typename //声明模板类型
union    //联合体
using  //可以替换typedef的功能
virtual //虚函数
void   //空类型
volatile //直接声明为定死的常量
wchar_t //表示宽字符的
while   //循环
xor        //异或 ^
xor_eq  //　^=</code></pre>
<p>实例</p>
<pre class=" language-c++"><code class="language-c++">#include <iostream>
#include <typeinfo>
#include <cassert>
#include <map>
//#include <algorithm>
//#include <vector>
//#include <list>
//#include <stack>
//#include <future>
//#include <functional>
using namespace std;
//---------------------------------------------------------------
//alignas
struct alignas(8) S {};
struct alignas(1) U {S s; }; //bad
struct Foo {
    int i;
    float f;
    char c;
};
struct Empty {};
struct alignas(64) Empty64 {};
struct alignas(1) Double { double d; };
struct Obj {char a; int b;};
//sizeof(Obj) == 8
//alignof(Obj) == 4
void alignInfo() {
    cout << "Alignment of" << endl
        <<"_char             : " << alignof(char) << endl
        <<"_pointer          : " << alignof(int*) << endl
        <<"_class Foo        : " << alignof(Foo) << endl;
}
//---------------------------------------------------------------
//and
void showAnd() {
    int a = 3;
    int b = 4;
    if(a == 3 && b == 4) {
        cout << "&& a = 3, b = 4";
    }
    if(a == 3 and b == 4) {
        cout << "and a = 3, b = 4";
    }
}
//---------------------------------------------------------------
//and_eq   <=>  &=
void testAnd_eq() {
    bool a = false;
    bool b = true;
    b = b and_eq a;
    cout << b << endl;
    bool c = true;
    c and_eq a;
    cout << "c: " << c << endl;
}
//---------------------------------------------------------------
//not <=> !
void testNot() {

    bool a = true;    
    bool b = not(a);
    cout << b;
}
//---------------------------------------------------------------
//not_eq <=> !=
void testNot_eq() {
    bool a = true;
    a not_eq(a);
    cout << a;
}
//---------------------------------------------------------------
//or <=> |
void testOr() {
    int a = 3;
    cout << a or 2;
}
//---------------------------------------------------------------
//or <=> |=
void testOr_eq() {
    int a = 3;
    a or_eq 4;
    cout << a;
}
//---------------------------------------------------------------
void showAsm() {
    asm (
    "movq $60, %rax\n\t" //the exit syscall number on linux
    "movq $2,  %rdi\n\t" //this program returns 2
    "syscall"
    );
}
//---------------------------------------------------------------
int get_fun(int x) {
    return x + 1;
}
double add(double a, double b) {
    return a + b;
}
void showAuto() {
    auto a = 1 + 2;
    cout << "type of a: " << typeid(a).name() << endl;
    auto b = add(1, 1.2);
    cout << "type of b: " << typeid(b).name() << endl;
    auto c = {1, 2}; //初始化列表
    cout << "type of c: " << typeid(c).name() << endl;

    auto my_lambda = [](int x) { return x + 3; };
    cout << "type of my_lambda: " << typeid(my_lambda).name() << endl;

    auto my_fun = get_fun;
    cout << "my_fun: " << my_fun(3) << endl;

    cout << "type of my_fun: " << typeid(my_fun).name() << endl;

}
//---------------------------------------------------------------
void showBitAndOr() {
    auto a = 3l; //long int
    auto b = 4;
    auto c = a bitand b;
    auto d = a bitor b;
    cout << "c: " << c << "d: " << d;
}
//---------------------------------------------------------------
void testBool() {
    bool a = true;
    bool b = false;
    *(reinterpret_cast<char *>(&a)) = -1;
    cout << a << " " << b << endl;
    if(a == true) {
        cout << "i'm true";
    }else if(a == false){
        cout << "i'm false";
    }else {
        cout << "What?";
    }
}
//---------------------------------------------------------------
void testBreak() {
    int a = 10;
    for(;;) {
        for(;;) {
            ++a;    
            if(a > 1000) break;
        }    
        if(a > 100000000) break;
    }
}
//---------------------------------------------------------------
void testCompl() {
    int a = -3;
    int b = compl(a); // compl(a) <=> ~a
    cout << b;
}
//---------------------------------------------------------------
int fact(int n) {
    return n < 1 ? 1 : (n * fact(n - 1));
}
constexpr int factorial(int n) {
    return n < 1 ? 1 : (n * factorial(n - 1));
}
template<int N>
struct NN{
    void print() { cout << N << endl;}
};
void testConstExpr() {
    auto a = fact(4); //运行时计算
    auto b = factorial(4); //编译时计算, 类似于宏定义计算
    cout << "a: " << a << " b: " << b << endl;
    char group[factorial(5)];
    NN<factorial(8)> nn;
    nn.print();
}
//---------------------------------------------------------------
/*
void testThread(const int &a) {
    cout << "thread"    
}*/
void testConst_cast() {
    const int i = 3;
    //const int*
    int *p = const_cast<int*>(&i);
//    std::thread aa([&i](){ testThread(i); });
    *p = 5;
    cout << p << endl << &i << endl;
    cout << i << "  " << *p << endl;
}
//---------------------------------------------------------------
//decltype 与 auto 十分相近
struct A {A(int n) : x(n) {} double x;};
void testDecltype() {
    const A* a = new A(0);
    auto aa = a->x;
    decltype(a->x) y; // 相当于auto  aa = a->x
    decltype((a->x)) z = y; //相当于 auto & z = y, 引用
    y = 3;
//    z = 4;
    cout << y << endl << z;
}
// 写一个相加函数, 实现不确定类型相加的函数
template<typename T, typename U>
auto add(T a, U b) -> decltype(a + b) { //decltype(a + b) 推导出返回值类型
    return a + b;
}
/*
//陷阱: auto 
template<typename T, typename U>
auto add(Ta, Ub) {}
    return a + b;
    // return a + b 与 return (a + b) 可能表示的意义不同, 后者可能代表引用
}*/
//---------------------------------------------------------------
struct Base { virtual ~Base() {} };
struct Drive : Base {
    virtual void name() {}
};
void testDynamic_cast() {
    Base *b1 = new Base;
    //这里会调用不成功
    if(Drive *d = dynamic_cast<Drive *>(b1)) {
        std::cout << "downcast from b1 to d successful" << std::endl;    
        d->name(); //safe to call
    }

    Base *b2 = new Drive;
    //这里会调用成功
    if(Drive *d = dynamic_cast<Drive *>(b2)) {
        std::cout << "downcast from b2 to d successful" << std::endl;    
        d->name(); //safe to call
    }
    //对于dynamic_cast转换引用,若转化失败,则会抛出异常
    //dynamic_cast 在运行期进行检查 
    /*
    Base bb; 
    Drive& cc = dynamic_cast<Drive&>(bb);
    */
}
//---------------------------------------------------------------
enum Color { red, green, blue };
//老的版本中,若出现 enmu Color2 {red, green, blue}; 就会出先重复的元素,就会报错
void testOldEnum() {
    Color r = red;
    switch(r) {
        case red:
            std::cout << "red" << std::endl;
        break;
        case green:
            std::cout << "green" << std::endl;
        break;
        case blue:
            std::cout << "blue" << std::endl;
        break;
        default:
            std::cout << "what ?" << std::endl;
    }
}
enum class NewColor {red, green, blue = green + 12};
enum class MyColor : short {black}; //通过short指定元素的类型为short

//若以bool作为函数参数, 建议使用enum来代替bool参数.
enum class IsGood {Yes, No};
enum class IsOk {Yes, No};
void enumBoolTest(IsGood isGood, IsOk isOk) {
}

void testNewEnum() {
    NewColor r = NewColor::blue;
    switch(r) {
        case NewColor::blue: {
            cout << "new blue" << endl;                         
        } break;
        case NewColor::red: {
            cout << "new red" << endl;                         
        } break;
        case NewColor::green: {
            cout << "new green" << endl; 
        } break;
        default:
            cout << "new what?" << endl;
    }

    int i = static_cast<int>(blue) + static_cast<int>(NewColor::blue);
    cout << "blud + NewColor::blue = " << i << endl;
    enumBoolTest(IsGood::Yes, IsOk::No);
}
//---------------------------------------------------------------
//test explicit
struct AA {
    AA(int) {}
    AA(int, int) {}
    operator int() const { return 0; } //AA可以默认的转化为int类型
};
struct BB {
    explicit BB(int) {}
    BB(int, int) {}
    explicit operator int() const { return 0; }
};
void testExplicit() {
    AA a1 = 1; //等价于 AA a1 = AA(1);
    //而BB就不能 BB b = 1;
    AA a2 = {3, 5}; //等价于 AA a1 = AA(3, 5);
    BB b2 = {3, 5}; //BB中B(int, int)没有加explicit
    int i = a1; //能通过
    //而BB就不能 int i = b2;
    //将BB强转.
    int na2 = static_cast<int>(a1);
    int nb2 = static_cast<int>(b2); //强转explicit　可以
    AA a4 = (AA)3;
    BB b3 = (BB)4; //通过C语言方式强制转换, 可以
}
//---------------------------------------------------------------
//friend
class MyClass {};
class Friend {
    private:
        int data; //private member
    friend std::ostream &operator << (std::ostream &out, const Friend &o);
    //Mycla　类是Fried类的好友, 只是单向
    template <typename T> friend class MyCla;  //every MyClass<T> is a friend of Friend
    template <typename T> friend void f(T) {} //every f<T> if a friend of Firend
    public:
    Friend(int x) : data(x) {}
    operator int() const { return this->data; }
};
//这样可以拿这个函数当公共函数访问私有成员
std::ostream &operator << (std::ostream &out, const Friend &f) {
    return out << f.data;
}
//若发生继承关系, MyCla不是, Friend2 的好友.
class Friend2 : public Friend { };

void testFriend() {
        Friend a = 44;
    cout << a;
}
//---------------------------------------------------------------
//goto
void testGoto() {
    auto i = 0;
NO:
    if(i < 5) {
        cout << i;
        i ++;
        goto NO;    
    }
}
//---------------------------------------------------------------
//inline
//尽量的减少栈空间开辟和回收操作
//类和模板函数,默认会加上inline进行优化.
//但不一定快
//inline 也可以与 namespace一起用， inline namespace
inline int plus(int a, int b) {
    return a + b;
}
class Inline {
    //在类中的函数里,编译器会默认加上inline进行优化
    public:
        void Member() const { std::cout << "hello\n"; }
        int vlaue() const { return this->m_value; }
    private:
        int m_value;
};
//---------------------------------------------------------------
//namespace
namespace XGroup {
    class A_ {
        int value;    
    };
}
namespace YGroup {
    class A_ {
        int value;    
    };
    class B_ {
        int value;    
    };
}
void testNmaespace() {
    XGroup::A_ a;    
    YGroup::A_ b;    
}
void testNamespace2() {
    using namespace XGroup;
    A_ a;
    using namespace YGroup;
    B_ b; //可以不用写 YGroup::B_
}
void testNamespace3() {
    namespace CGroup = XGroup;    
    CGroup::A_ a;
    using YGroup::B_;
    B_ b;
}
//没有名字的namespace
namespace {
    std::string astring("long"); //相当于　static std::string astirng
}
void testNamespace4() {
    cout << astring; //打印astring
}
//---------------------------------------------------------------
//noexcept
void noexCept() noexcept { //声明确定不会抛出异常,可以减轻编译器压力,利于优化代码.
    std::cout << "hello" << std::endl;
    //std::terminate(); abort(); exit(0);
}
void noexCept2() noexcept(false) { //等价于没写
    std::cout << "hello" << std::endl;
}
//---------------------------------------------------------------
void nullPointer(int *a) {
}
template<typename T, typename U>
void func(T t, U u) {
    t(u);
}
void testNullPointer() {
    //三者直接调用,结果一样
    nullPointer(0);
    nullPointer(NULL); //(void*)0
    nullPointer(nullptr); //std::nullptr_t 在c++11中有专有的类型
    //利用模板函数之后, NULL 模板函数推导为int
    func(nullPointer, nullptr);
    //不能调用　
//    func(nullPointer, NULL);
//    func(nullPointer, 0);
    //若想调用,需要强制转换　
    func(nullPointer, (int*)0);
    func(nullPointer, (int*)NULL);
}
//---------------------------------------------------------------
//operator
struct Operator {
    public:
        Operator(int x) : data(x) { }
//    operator int() const { return this->data; }
    int operator << (Operator const& o) const {
        return data + o.data;
    }
    int operator & () const { return data; }
    private:
    int data;
};
void testOperator() {
    Operator a = 10;
    Operator b = 5;
    Operator c = a << b; //实际实现相加
    cout << &c << endl; //采用去地址符号实现返回里面的值
}
//实例应用:
/*
struct AClass {
    ~AClass() { delete m_value}
    AClass() : m_value(new int()) {}
    private:
    int *m_value;
}
void test() {
    Aclass A;
    Aclass B;
    A = B; //这种情况,里面的值m_value,会发生直接赋值,A和B直接指向同一块内存,
    //会发生两次析构,内存会错误.

} */
//使用操作符重载 = 来避免:
struct AClass {
    ~AClass() { delete m_value;}
    AClass(const AClass& rhs) : m_value(new int(*(rhs.m_value))) {}
    AClass& operator = (const AClass& rhs) {
        *m_value = *(rhs.m_value);
        return *this;
    }
    private:
        int *m_value;
};
//---------------------------------------------------------------
//reinterpret_cast
void testReinterpret_cast() {
    //reinterpret_cast
    //static_cast
    //const_cast
    //dynamic_cast
    //c like cast　可以实现以上的大部分, 而dynamic_cast c语言这种方式不能实现的

    int a = 1;
    // 也相当于 char* p = (char*)&a;
    auto p = reinterpret_cast<char *>(&a); //转化为char*
    //不能char* b = static_cast<char*> &b;
    if(p[0] = 1) {
        std::cout << "the system is little endian\n";
    }else {
        std::cout << "the system is big endian\n";
    }
}
//---------------------------------------------------------------
//sizeof, before c++11
struct SizeofEmpty {};
struct SizeofBase { int a;};
struct SizeofDerived : Base{ int b;};
struct SizeofBit {unsigned bit : 1;};
void testSizeof() {
    SizeofEmpty e;
    SizeofDerived d;
    SizeofBase b;
    SizeofBit bit;
    cout << "sizeof empty: " << sizeof e << endl;
    cout << "sizeof derived: " << sizeof d << endl;
    cout << "sizeof base: " << sizeof(b) << endl;
    cout << "sizeof bit: " << sizeof(SizeofBit) << endl;
//    cout << "szieof void" << sizeof(void) << endl;
//    cout << "szieof int[]" << sizeof(int[]) << endl;
}
//---------------------------------------------------------------
//static
//最好要这么用
static int globalA = 0;
void printInfo() {
    static int localStatic = 0; //多线程不要这么用
    ++ localStatic;
    cout << "globalA: " << globalA << " " << "localStatic: " << localStatic << endl;
}
struct Static {
    static int s; //注意: sizeof(Static) == 1, s的空间已经分配
};
int Static::s = 10;

struct HeHe {};
struct Static2 {
    static int a[];
    static HeHe foo;
    static Static2 ss;
};
//对成员进行实例化
int Static2::a[10];
HeHe Static2::foo;
Static2 Static2::ss;

//---------------------------------------------------------------
//static_assert c++11的一个宏, 在编译期进行检测
//assert 是在运行的时候进行检测
void testStaticAssert() {
    static_assert(sizeof(int) == 4, "only work for int of 32bit");
    static_assert(sizeof(long) == sizeof(long long),
            "only work for int of 32bit");
    int a = 5; //判断变量 a == b 采用assert
    int b = 5;
    assert(a != b && "error"); 
}
template<typename T>
void static_assertFun() {
    static_assert(alignof(T) ==4, "only for alignof 4");
}
//---------------------------------------------------------------
//typedef , 换名称
typedef unsigned long ulong;
class Comp {
    typedef std::map<int, ulong> Group;
    Group a; //相当于 std::map<int, ulong> a;
    void aa() {
        //std::map<int, ulong>::iterator iter = a.find(10)
        Group::iterator iter = a.find(10);
        //也可以使用: auto iter = a.fine(10);
    }
};
//---------------------------------------------------------------
//using 
//可以使用与namespace,也可以替换typedef
using newGroup = std::map<int, ulong>;

//using namespace std;

//---------------------------------------------------------------

int main(void) {
//    showAuto();
//    showBitAndOr();
//    showAsm();
//    testAnd_eq();
//    testNot();
//    testNot_eq();
//    testBool();
//    testBreak();
//    testCompl();
//    testConstExpr();
//    testConst_cast();
//    testDecltype();
//    testDynamic_cast();
//    testOldEnum();
//    testNewEnum();
//    testExplicit();
//    testFriend();
//    testGoto();
//    testNamespace4();
//    testOperator();
//    testReinterpret_cast();
//    testSizeof();
    testStaticAssert();

    return 0;
}</code></pre>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">i0gan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://blog.i0gan.cn/2020/02/22/c++-keywords/">http://blog.i0gan.cn/2020/02/22/c++-keywords/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/c/">c++</a></div><div class="post_share"><div class="social-share" data-image="/img/text_bg.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2020/02/22/c++-principle/"><img class="prev-cover" src="/img/text_bg.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">C++ Principle</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2020/02/24/c++-class/" title="C++ Class"><img class="cover" src="/img/text_bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-24</div><div class="title">C++ Class</div></div></a></div><div><a href="/2020/02/23/c++-others/" title="C++ Others"><img class="cover" src="/img/text_bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-23</div><div class="title">C++ Others</div></div></a></div><div><a href="/2020/02/22/c++-principle/" title="C++ Principle"><img class="cover" src="/img/text_bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-22</div><div class="title">C++ Principle</div></div></a></div><div><a href="/2020/02/24/c++-smart-pointer/" title="C++ Smart Pointer"><img class="cover" src="/img/text_bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-24</div><div class="title">C++ Smart Pointer</div></div></a></div><div><a href="/2020/02/24/c++-stl/" title="C++ STL"><img class="cover" src="/img/text_bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-24</div><div class="title">C++ STL</div></div></a></div><div><a href="/2021/04/02/wp-maybe-fun-game/" title="Maybe fun game"><img class="cover" src="/img/text_bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-02</div><div class="title">Maybe fun game</div></div></a></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/header.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">i0gan</div><div class="author-info__description">Even if a man has reached the top, he still needs to improve himself</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">61</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">28</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">23</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/i0gan"><i class="fab fa-github"></i><span>Follow Me</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Keywords-of-C"><span class="toc-number">1.</span> <span class="toc-text">Keywords of C++</span></a></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/04/02/wp-maybe-fun-game/" title="Maybe fun game"><img src="/img/text_bg.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Maybe fun game"/></a><div class="content"><a class="title" href="/2021/04/02/wp-maybe-fun-game/" title="Maybe fun game">Maybe fun game</a><time datetime="2021-04-02T12:01:00.000Z" title="Created 2021-04-02 20:01:00">2021-04-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/01/cve-2021-3156/" title="Heap-Based Buffer Overflow in Sudo"><img src="/img/text_bg.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Heap-Based Buffer Overflow in Sudo"/></a><div class="content"><a class="title" href="/2021/04/01/cve-2021-3156/" title="Heap-Based Buffer Overflow in Sudo">Heap-Based Buffer Overflow in Sudo</a><time datetime="2021-03-31T16:48:43.000Z" title="Created 2021-04-01 00:48:43">2021-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/03/31/auto-pwn/" title="AUTO PWN"><img src="/img/text_bg.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AUTO PWN"/></a><div class="content"><a class="title" href="/2021/03/31/auto-pwn/" title="AUTO PWN">AUTO PWN</a><time datetime="2021-03-31T07:58:43.000Z" title="Created 2021-03-31 15:58:43">2021-03-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/03/31/fuzz-afl/" title="Binary fuzzing way of american fuzzy lop"><img src="/img/text_bg.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Binary fuzzing way of american fuzzy lop"/></a><div class="content"><a class="title" href="/2021/03/31/fuzz-afl/" title="Binary fuzzing way of american fuzzy lop">Binary fuzzing way of american fuzzy lop</a><time datetime="2021-03-31T02:00:43.000Z" title="Created 2021-03-31 10:00:43">2021-03-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/03/30/v8-01/" title="V8 EXPLOIT ONE"><img src="/img/text_bg.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="V8 EXPLOIT ONE"/></a><div class="content"><a class="title" href="/2021/03/30/v8-01/" title="V8 EXPLOIT ONE">V8 EXPLOIT ONE</a><time datetime="2021-03-30T11:28:43.000Z" title="Created 2021-03-30 19:28:43">2021-03-30</time></div></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/text_bg.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By i0gan</div><div class="framework-info"></div><div class="icp"><a target="_blank" rel="noopener" href="http://www.beian.gov.cn/"><img class="icp-icon" src="/img/icp.png" alt="ICP"/><span>黔ICP备20006037号</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>
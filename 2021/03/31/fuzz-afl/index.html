<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Binary fuzzing way of american fuzzy lop | I0gan</title><meta name="keywords" content="fuzz"><meta name="author" content="i0gan"><meta name="copyright" content="i0gan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="Binary fuzzing way of american fuzzy lopIntroThe github project is here: https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;AFL This paper refer to the official document: https:&#x2F;&#x2F;afl-1.readthedocs.io&#x2F; What is AFL?¶American fu">
<meta property="og:type" content="article">
<meta property="og:title" content="Binary fuzzing way of american fuzzy lop">
<meta property="og:url" content="http://blog.i0gan.cn/2021/03/31/fuzz-afl/index.html">
<meta property="og:site_name" content="I0gan">
<meta property="og:description" content="Binary fuzzing way of american fuzzy lopIntroThe github project is here: https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;AFL This paper refer to the official document: https:&#x2F;&#x2F;afl-1.readthedocs.io&#x2F; What is AFL?¶American fu">
<meta property="og:locale">
<meta property="og:image" content="http://blog.i0gan.cn/img/text_bg.jpg">
<meta property="article:published_time" content="2021-03-31T02:00:43.000Z">
<meta property="article:modified_time" content="2021-03-31T03:44:01.060Z">
<meta property="article:author" content="i0gan">
<meta property="article:tag" content="fuzz">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://blog.i0gan.cn/img/text_bg.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://blog.i0gan.cn/2021/03/31/fuzz-afl/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-03-31 11:44:01'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.2.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/header.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">52</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">27</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">22</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/text_bg.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">I0gan</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">Binary fuzzing way of american fuzzy lop</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-03-31T02:00:43.000Z" title="Created 2021-03-31 10:00:43">2021-03-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-03-31T03:44:01.060Z" title="Updated 2021-03-31 11:44:01">2021-03-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/fuzz/">fuzz</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Binary-fuzzing-way-of-american-fuzzy-lop"><a href="#Binary-fuzzing-way-of-american-fuzzy-lop" class="headerlink" title="Binary fuzzing way of american fuzzy lop"></a>Binary fuzzing way of american fuzzy lop</h1><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>The github project is here: <a target="_blank" rel="noopener" href="https://github.com/google/AFL">https://github.com/google/AFL</a></p>
<p>This paper refer to the official document: <a target="_blank" rel="noopener" href="https://afl-1.readthedocs.io/">https://afl-1.readthedocs.io/</a></p>
<h3 id="What-is-AFL-¶"><a href="#What-is-AFL-¶" class="headerlink" title="What is AFL?¶"></a>What is AFL?<a target="_blank" rel="noopener" href="https://afl-1.readthedocs.io/en/latest/index.html#what-is-afl">¶</a></h3><p>American fuzzy lop is a security-oriented fuzzer that employs a novel type of compile-time instrumentation and genetic algorithms to automatically discover clean, interesting test cases that trigger new internal states in the targeted binary. This substantially improves the functional coverage for the fuzzed code. The compact synthesized corpora produced by the tool are also useful for seeding other, more labor- or resource-intensive testing regimes down the road.</p>
<h2 id="How-to-install-env"><a href="#How-to-install-env" class="headerlink" title="How to install env"></a>How to install env</h2><h3 id="Method-1"><a href="#Method-1" class="headerlink" title="Method 1"></a>Method 1</h3><pre><code>sudo pacman -S afl-utils
sudo pacman -S afl</code></pre>
<p>Input afl and press Tab Tab output as follows:</p>
<pre><code>sh: afl-
afl-analyze       afl-clang-fast++  afl-fuzz          afl-minimize      afl-showmap       afl-vcrash      
afl-clang         afl-cmin          afl-g++           afl-multicore     afl-stats         afl-whatsup     
afl-clang++       afl-collect       afl-gcc           afl-multikill     afl-sync                          
afl-clang-fast    afl-cron          afl-gotcpu        afl-plot          afl-tmin </code></pre>
<p>So you can use these tools to start fuzzing.</p>
<h3 id="Method-2"><a href="#Method-2" class="headerlink" title="Method 2"></a>Method 2</h3><pre><code>git clone https://github.com/google/AFL.git
cd afl-master
make -j
sudo make install</code></pre>
<h2 id="How-it-works"><a href="#How-it-works" class="headerlink" title="How it works?"></a>How it works?</h2><p>Copy from doc: click <a target="_blank" rel="noopener" href="https://afl-1.readthedocs.io/en/latest/about_afl.html#how-afl-works">here</a> show details.</p>
<h3 id="0x00-Technical"><a href="#0x00-Technical" class="headerlink" title="0x00 Technical"></a>0x00 Technical</h3><p>Technical “whitepaper” for afl-fuzz.</p>
<h3 id="0x01-Coverage-measurements"><a href="#0x01-Coverage-measurements" class="headerlink" title="0x01 Coverage measurements"></a>0x01 Coverage measurements</h3><p>The instrumentation injected into complied programs captures branch (edge) coverage, along with coarse branch-taken (采取粗分枝) hit counts. The code injected at branch points is essentially equivalent to</p>
<pre><code>cur_location = &lt;COMPILE_TIME_RANDOM&gt;;
shared_mem[cur_location ^ prev_location]++;
prev_location = cur_location &gt;&gt; 1;</code></pre>
<p>The cur_location value is generated randomly to simplify the process of linking complex projects and keep the XOR output distributed uniformly.</p>
<p>The <code>shared_mem[]</code> array is a 64 KB <code>SHM</code> region passed to the instrumented binary by the caller. Every byte set in the output map can be thought of as a hit for a particular <code>(branch_src, branch_dst)</code> tuple in the instrumented code.</p>
<p>The size of the map is chosen so that collisions are sporadic with almost all of the intended targets, which usually sport between 2k and 10k discoverable branch points:</p>
<blockquote>
<table>
<thead>
<tr>
<th align="left">Branch cnt</th>
<th align="left">Colliding tuples</th>
<th align="left">Example targets</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1,000</td>
<td align="left">0.75%</td>
<td align="left">giflib, lzo</td>
</tr>
<tr>
<td align="left">2,000</td>
<td align="left">1.5%</td>
<td align="left">zlib, tar, xz</td>
</tr>
<tr>
<td align="left">5,000</td>
<td align="left">3.5%</td>
<td align="left">libpng, libwebp</td>
</tr>
<tr>
<td align="left">10,000</td>
<td align="left">7%</td>
<td align="left">libxml</td>
</tr>
<tr>
<td align="left">20,000</td>
<td align="left">14%</td>
<td align="left">sqlite</td>
</tr>
<tr>
<td align="left">50,000</td>
<td align="left">30%</td>
<td align="left"></td>
</tr>
</tbody></table>
</blockquote>
<p>At the same time, its size is small enough to allow the map to be analyzed in a matter of microseconds on the receiving end, and to effortlessly fit within L2 cache.</p>
<p>This form of coverage provides considerably more insight into the execution path of the program than simple block coverage. In particular, it trivially distinguishes between the following execution traces:</p>
<pre><code>A -&gt; B -&gt; C -&gt; D -&gt; E (tuples: AB, BC, CD, DE)
A -&gt; B -&gt; D -&gt; C -&gt; E (tuples: AB, BD, DC, CE)</code></pre>
<p>This aids the discovery of subtle fault conditions in the underlying code, because security vulnerabilities are more often associated with unexpected or incorrect state transitions than with merely reaching a new basic block.</p>
<p>The reason for the shift operation in the last line of the pseudocode shown earlier in this section is to preserve the directionality of tuples (without this, A ^ B would be indistinguishable from B ^ A) and to retain the identity of tight loops (otherwise, A ^ A would be obviously equal to B ^ B).</p>
<p>The absence of simple saturating arithmetic opcodes on Intel CPUs means that the hit counters can sometimes wrap around to zero. Since this is a fairly unlikely and localized event, it’s seen as an acceptable performance trade-off.</p>
<h3 id="0x02-Detecting-new-behaviors"><a href="#0x02-Detecting-new-behaviors" class="headerlink" title="0x02 Detecting new behaviors"></a>0x02 Detecting new behaviors</h3><p>The fuzzer maintains a global map of tuples seen in previous executions; this data can be rapidly compared with individual traces and updated in just a couple of dword- or qword-wide instructions and a simple loop.</p>
<p>When a mutated input produces an execution trace containing new tuples, the corresponding input file is preserved and routed for additional processing later on (see section #3). Inputs that do not trigger new local-scale state transitions in the execution trace (i.e., produce no new tuples) are discarded, even if their overall control flow sequence is unique.</p>
<p>This approach allows for a very fine-grained and long-term exploration of program state while not having to perform any computationally intensive and fragile global comparisons of complex execution traces, and while avoiding the scourge of path explosion.</p>
<p>To illustrate the properties of the algorithm, consider that the second trace shown below would be considered substantially new because of the presence of new tuples (CA, AE):</p>
<pre><code>#1: A -&gt; B -&gt; C -&gt; D -&gt; E
#2: A -&gt; B -&gt; C -&gt; A -&gt; E</code></pre>
<p>At the same time, with #2 processed, the following pattern will not be seen as unique, despite having a markedly different overall execution path:</p>
<pre><code>#3: A -&gt; B -&gt; C -&gt; A -&gt; B -&gt; C -&gt; A -&gt; B -&gt; C -&gt; D -&gt; E</code></pre>
<p>In addition to detecting new tuples, the fuzzer also considers coarse tuple hit counts. These are divided into several buckets:</p>
<pre><code>1, 2, 3, 4-7, 8-15, 16-31, 32-127, 128+</code></pre>
<p>To some extent, the number of buckets is an implementation artifact: it allows an in-place mapping of an 8-bit counter generated by the instrumentation to an 8-position bitmap relied on by the fuzzer executable to keep track of the already-seen execution counts for each tuple.</p>
<p>Changes within the range of a single bucket are ignored; transition from one bucket to another is flagged as an interesting change in program control flow, and is routed to the evolutionary process outlined in the section below.</p>
<p>The hit count behavior provides a way to distinguish between potentially interesting control flow changes, such as a block of code being executed twice when it was normally hit only once. At the same time, it is fairly insensitive to empirically less notable changes, such as a loop going from 47 cycles to 48. The counters also provide some degree of “accidental” immunity against tuple collisions in dense trace maps.</p>
<p>The execution is policed fairly heavily through memory and execution time limits; by default, the timeout is set at 5x the initially-calibrated execution speed, rounded up to 20 ms. The aggressive timeouts are meant to prevent dramatic fuzzer performance degradation by descending into tarpits that, say, improve coverage by 1% while being 100x slower; we pragmatically reject them and hope that the fuzzer will find a less expensive way to reach the same code. Empirical testing strongly suggests that more generous time limits are not worth the cost.</p>
<h3 id="0x03-Evolving-the-input-queue"><a href="#0x03-Evolving-the-input-queue" class="headerlink" title="0x03 Evolving the input queue"></a>0x03 Evolving the input queue</h3><p>Mutated test cases that produced new state transitions within the program are added to the input queue and used as a starting point for future rounds of fuzzing. They supplement, but do not automatically replace, existing finds.</p>
<p>In contrast to more greedy genetic algorithms, this approach allows the tool to progressively explore various disjoint and possibly mutually incompatible features of the underlying data format, as shown in this image:</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://lcamtuf.coredump.cx/afl/afl_gzip.png">http://lcamtuf.coredump.cx/afl/afl_gzip.png</a></p>
</blockquote>
<p>Several practical examples of the results of this algorithm are discussed here:</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://lcamtuf.blogspot.com/2014/11/pulling-jpegs-out-of-thin-air.html">http://lcamtuf.blogspot.com/2014/11/pulling-jpegs-out-of-thin-air.html</a> <a target="_blank" rel="noopener" href="http://lcamtuf.blogspot.com/2014/11/afl-fuzz-nobody-expects-cdata-sections.html">http://lcamtuf.blogspot.com/2014/11/afl-fuzz-nobody-expects-cdata-sections.html</a></p>
</blockquote>
<p>The synthetic corpus produced by this process is essentially a compact collection of “hmm, this does something new!” input files, and can be used to seed any other testing processes down the line (for example, to manually stress-test resource-intensive desktop apps).</p>
<p>With this approach, the queue for most targets grows to somewhere between 1k and 10k entries; approximately 10-30% of this is attributable to the discovery of new tuples, and the remainder is associated with changes in hit counts.</p>
<p>The following table compares the relative ability to discover file syntax and explore program states when using several different approaches to guided fuzzing. The instrumented target was GNU patch 2.7.3 compiled with -O3 and seeded with a dummy text file; the session consisted of a single pass over the input queue with afl-fuzz:</p>
<blockquote>
<table>
<thead>
<tr>
<th align="left">Fuzzer guidance strategy used</th>
<th align="left">Blocks reached</th>
<th align="left">Edges reached</th>
<th align="left">Edge hit cnt var</th>
<th align="left">Highest-coverage test case generated</th>
</tr>
</thead>
<tbody><tr>
<td align="left">(Initial file)</td>
<td align="left">156</td>
<td align="left">163</td>
<td align="left">1.00</td>
<td align="left">(none)</td>
</tr>
<tr>
<td align="left">Blind fuzzing S</td>
<td align="left">182</td>
<td align="left">205</td>
<td align="left">2.23</td>
<td align="left">First 2 B of RCS diff</td>
</tr>
<tr>
<td align="left">Blind fuzzing L</td>
<td align="left">228</td>
<td align="left">265</td>
<td align="left">2.23</td>
<td align="left">First 4 B of -c mode diff</td>
</tr>
<tr>
<td align="left">Block coverage</td>
<td align="left">855</td>
<td align="left">1,130</td>
<td align="left">1.57</td>
<td align="left">Almost-valid RCS diff</td>
</tr>
<tr>
<td align="left">Edge coverage</td>
<td align="left">1,452</td>
<td align="left">2,070</td>
<td align="left">2.18</td>
<td align="left">One-chunk -c mode diff</td>
</tr>
<tr>
<td align="left">AFL model</td>
<td align="left">1,765</td>
<td align="left">2,597</td>
<td align="left">4.99</td>
<td align="left">Four-chunk -c mode diff</td>
</tr>
</tbody></table>
</blockquote>
<p>The first entry for blind fuzzing (“S”) corresponds to executing just a single round of testing; the second set of figures (“L”) shows the fuzzer running in a loop for a number of execution cycles comparable with that of the instrumented runs, which required more time to fully process the growing queue.</p>
<p>Roughly similar results have been obtained in a separate experiment where the fuzzer was modified to compile out all the random fuzzing stages and leave just a series of rudimentary, sequential operations such as walking bit flips. Because this mode would be incapable of altering the size of the input file, the sessions were seeded with a valid unified diff:</p>
<blockquote>
<table>
<thead>
<tr>
<th align="left">Queue extension strategy used</th>
<th align="left">Blocks reached</th>
<th align="left">Edges reached</th>
<th align="left">Edge hit cnt var</th>
<th align="left">Number of unique crashes found</th>
</tr>
</thead>
<tbody><tr>
<td align="left">(Initial file)</td>
<td align="left">624</td>
<td align="left">717</td>
<td align="left">1.00</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Blind fuzzing</td>
<td align="left">1,101</td>
<td align="left">1,409</td>
<td align="left">1.60</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">Block coverage</td>
<td align="left">1,255</td>
<td align="left">1,649</td>
<td align="left">1.48</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">Edge coverage</td>
<td align="left">1,259</td>
<td align="left">1,734</td>
<td align="left">1.72</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">AFL model</td>
<td align="left">1,452</td>
<td align="left">2,040</td>
<td align="left">3.16</td>
<td align="left">1</td>
</tr>
</tbody></table>
</blockquote>
<p>At noted earlier on, some of the prior work on genetic fuzzing relied on maintaining a single test case and evolving it to maximize coverage. At least in the tests described above, this “greedy” approach appears to confer no substantial benefits over blind fuzzing strategies.</p>
<h3 id="0x04-Culling-the-corpus"><a href="#0x04-Culling-the-corpus" class="headerlink" title="0x04 Culling the corpus"></a>0x04 Culling the corpus</h3><p>The progressive state exploration approach outlined above means that some of the test cases synthesized later on in the game may have edge coverage that is a strict superset of the coverage provided by their ancestors.</p>
<p>To optimize the fuzzing effort, AFL periodically re-evaluates the queue using a fast algorithm that selects a smaller subset of test cases that still cover every tuple seen so far, and whose characteristics make them particularly favorable to the tool.</p>
<p>The algorithm works by assigning every queue entry a score proportional to its execution latency and file size; and then selecting lowest-scoring candidates for each tuple.</p>
<p>The tuples are then processed sequentially using a simple workflow:</p>
<blockquote>
<ol>
<li>Find next tuple not yet in the temporary working set,</li>
<li>Locate the winning queue entry for this tuple,</li>
<li>Register <em>all</em> tuples present in that entry’s trace in the working set,</li>
<li>Go to #1 if there are any missing tuples in the set.</li>
</ol>
</blockquote>
<p>The generated corpus of “favored” entries is usually 5-10x smaller than the starting data set. Non-favored entries are not discarded, but they are skipped with varying probabilities when encountered in the queue:</p>
<blockquote>
<ul>
<li>If there are new, yet-to-be-fuzzed favorites present in the queue, 99% of non-favored entries will be skipped to get to the favored ones.</li>
<li>If there are no new favorites:<ul>
<li>If the current non-favored entry was fuzzed before, it will be skipped 95% of the time.</li>
<li>If it hasn’t gone through any fuzzing rounds yet, the odds of skipping drop down to 75%.</li>
</ul>
</li>
</ul>
</blockquote>
<p>Based on empirical testing, this provides a reasonable balance between queue cycling speed and test case diversity.</p>
<p>Slightly more sophisticated but much slower culling can be performed on input or output corpora with afl-cmin. This tool permanently discards the redundant entries and produces a smaller corpus suitable for use with afl-fuzz or external tools.</p>
<h3 id="0x05-Trimming-input-files"><a href="#0x05-Trimming-input-files" class="headerlink" title="0x05 Trimming input files"></a>0x05 Trimming input files</h3><p>File size has a dramatic impact on fuzzing performance, both because large files make the target binary slower, and because they reduce the likelihood that a mutation would touch important format control structures, rather than redundant data blocks. This is discussed in more detail in <a target="_blank" rel="noopener" href="https://afl-1.readthedocs.io/en/latest/tips.html#performance-tips">Performance Tips</a>.</p>
<p>The possibility that the user will provide a low-quality starting corpus aside, some types of mutations can have the effect of iteratively increasing the size of the generated files, so it is important to counter this trend.</p>
<p>Luckily, the instrumentation feedback provides a simple way to automatically trim down input files while ensuring that the changes made to the files have no impact on the execution path.</p>
<p>The built-in trimmer in afl-fuzz attempts to sequentially remove blocks of data with variable length and stepover; any deletion that doesn’t affect the checksum of the trace map is committed to disk. The trimmer is not designed to be particularly thorough; instead, it tries to strike a balance between precision and the number of execve() calls spent on the process, selecting the block size and stepover to match. The average per-file gains are around 5-20%.</p>
<p>The standalone afl-tmin tool uses a more exhaustive, iterative algorithm, and also attempts to perform alphabet normalization on the trimmed files. The operation of afl-tmin is as follows.</p>
<p>First, the tool automatically selects the operating mode. If the initial input crashes the target binary, afl-tmin will run in non-instrumented mode, simply keeping any tweaks that produce a simpler file but still crash the target. If the target is non-crashing, the tool uses an instrumented mode and keeps only the tweaks that produce exactly the same execution path.</p>
<p>The actual minimization algorithm is:</p>
<blockquote>
<ol>
<li>Attempt to zero large blocks of data with large stepovers. Empirically, this is shown to reduce the number of execs by preempting finer-grained efforts later on.</li>
<li>Perform a block deletion pass with decreasing block sizes and stepovers, binary-search-style.</li>
<li>Perform alphabet normalization by counting unique characters and trying to bulk-replace each with a zero value.</li>
<li>As a last result, perform byte-by-byte normalization on non-zero bytes.</li>
</ol>
</blockquote>
<p>Instead of zeroing with a 0x00 byte, afl-tmin uses the ASCII digit ‘0’. This is done because such a modification is much less likely to interfere with text parsing, so it is more likely to result in successful minimization of text files.</p>
<p>The algorithm used here is less involved than some other test case minimization approaches proposed in academic work, but requires far fewer executions and tends to produce comparable results in most real-world applications.</p>
<h3 id="0x06-Fuzzing-strategies"><a href="#0x06-Fuzzing-strategies" class="headerlink" title="0x06 Fuzzing strategies"></a>0x06 Fuzzing strategies</h3><p>The feedback provided by the instrumentation makes it easy to understand the value of various fuzzing strategies and optimize their parameters so that they work equally well across a wide range of file types. The strategies used by afl-fuzz are generally format-agnostic and are discussed in more detail here:</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://lcamtuf.blogspot.com/2014/08/binary-fuzzing-strategies-what-works.html">http://lcamtuf.blogspot.com/2014/08/binary-fuzzing-strategies-what-works.html</a></p>
</blockquote>
<p>It is somewhat notable that especially early on, most of the work done by afl-fuzz is actually highly deterministic, and progresses to random stacked modifications and test case splicing only at a later stage. The deterministic strategies include:</p>
<blockquote>
<ul>
<li>Sequential bit flips with varying lengths and stepovers,</li>
<li>Sequential addition and subtraction of small integers,</li>
<li>Sequential insertion of known interesting integers (0, 1, INT_MAX, etc),</li>
</ul>
</blockquote>
<p>The purpose of opening with deterministic steps is related to their tendency to produce compact test cases and small diffs between the non-crashing and crashing inputs.</p>
<p>With deterministic fuzzing out of the way, the non-deterministic steps include stacked bit flips, insertions, deletions, arithmetics, and splicing of different test cases.</p>
<p>The relative yields and execve() costs of all these strategies have been investigated and are discussed in the aforementioned blog post.</p>
<p>For the reasons discussed in <a target="_blank" rel="noopener" href="https://afl-1.readthedocs.io/en/latest/about_afl.html#history">History</a> (chiefly, performance, simplicity, and reliability), AFL generally does not try to reason about the relationship between specific mutations and program states; the fuzzing steps are nominally blind, and are guided only by the evolutionary design of the input queue.</p>
<p>That said, there is one (trivial) exception to this rule: when a new queue entry goes through the initial set of deterministic fuzzing steps, and tweaks to some regions in the file are observed to have no effect on the checksum of the execution path, they may be excluded from the remaining phases of deterministic fuzzing - and the fuzzer may proceed straight to random tweaks. Especially for verbose, human-readable data formats, this can reduce the number of execs by 10-40% or so without an appreciable drop in coverage. In extreme cases, such as normally block-aligned tar archives, the gains can be as high as 90%.</p>
<p>Because the underlying “effector maps” are local every queue entry and remain in force only during deterministic stages that do not alter the size or the general layout of the underlying file, this mechanism appears to work very reliably and proved to be simple to implement.</p>
<h3 id="0x07-Dictionaries"><a href="#0x07-Dictionaries" class="headerlink" title="0x07 Dictionaries"></a>0x07 Dictionaries</h3><p>The feedback provided by the instrumentation makes it easy to automatically identify syntax tokens in some types of input files, and to detect that certain combinations of predefined or auto-detected dictionary terms constitute a valid grammar for the tested parser.</p>
<p>A discussion of how these features are implemented within afl-fuzz can be found here:</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://lcamtuf.blogspot.com/2015/01/afl-fuzz-making-up-grammar-with.html">http://lcamtuf.blogspot.com/2015/01/afl-fuzz-making-up-grammar-with.html</a></p>
</blockquote>
<p>In essence, when basic, typically easily-obtained syntax tokens are combined together in a purely random manner, the instrumentation and the evolutionary design of the queue together provide a feedback mechanism to differentiate between meaningless mutations and ones that trigger new behaviors in the instrumented code - and to incrementally build more complex syntax on top of this discovery.</p>
<p>The dictionaries have been shown to enable the fuzzer to rapidly reconstruct the grammar of highly verbose and complex languages such as JavaScript, SQL, or XML; several examples of generated SQL statements are given in the blog post mentioned above.</p>
<p>Interestingly, the AFL instrumentation also allows the fuzzer to automatically isolate syntax tokens already present in an input file. It can do so by looking for run of bytes that, when flipped, produce a consistent change to the program’s execution path; this is suggestive of an underlying atomic comparison to a predefined value baked into the code. The fuzzer relies on this signal to build compact “auto dictionaries” that are then used in conjunction with other fuzzing strategies.</p>
<h3 id="0x08-De-duping-crashes"><a href="#0x08-De-duping-crashes" class="headerlink" title="0x08 De-duping crashes"></a>0x08 De-duping crashes</h3><p>De-duplication of crashes is one of the more important problems for any competent fuzzing tool. Many of the naive approaches run into problems; in particular, looking just at the faulting address may lead to completely unrelated issues being clustered together if the fault happens in a common library function (say, strcmp, strcpy); while checksumming call stack backtraces can lead to extreme crash count inflation if the fault can be reached through a number of different, possibly recursive code paths.</p>
<p>The solution implemented in afl-fuzz considers a crash unique if any of two conditions are met:</p>
<blockquote>
<ul>
<li>The crash trace includes a tuple not seen in any of the previous crashes,</li>
<li>The crash trace is missing a tuple that was always present in earlier faults.</li>
</ul>
</blockquote>
<p>The approach is vulnerable to some path count inflation early on, but exhibits a very strong self-limiting effect, similar to the execution path analysis logic that is the cornerstone of afl-fuzz.</p>
<h3 id="Investigating-crashes"><a href="#Investigating-crashes" class="headerlink" title="Investigating crashes"></a>Investigating crashes</h3><p>The exploitability of many types of crashes can be ambiguous; afl-fuzz tries to address this by providing a crash exploration mode where a known-faulting test case is fuzzed in a manner very similar to the normal operation of the fuzzer, but with a constraint that causes any non-crashing mutations to be thrown away.</p>
<p>A detailed discussion of the value of this approach can be found here:</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://lcamtuf.blogspot.com/2014/11/afl-fuzz-crash-exploration-mode.html">http://lcamtuf.blogspot.com/2014/11/afl-fuzz-crash-exploration-mode.html</a></p>
</blockquote>
<p>The method uses instrumentation feedback to explore the state of the crashing program to get past the ambiguous faulting condition and then isolate the newly-found inputs for human review.</p>
<p>On the subject of crashes, it is worth noting that in contrast to normal queue entries, crashing inputs are <em>not</em> trimmed; they are kept exactly as discovered to make it easier to compare them to the parent, non-crashing entry in the queue. That said, afl-tmin can be used to shrink them at will.</p>
<h3 id="0x09-The-fork-server"><a href="#0x09-The-fork-server" class="headerlink" title="0x09 The fork server"></a>0x09 The fork server</h3><p>To improve performance, afl-fuzz uses a “fork server”, where the fuzzed process goes through execve(), linking, and libc initialization only once, and is then cloned from a stopped process image by leveraging copy-on-write. The implementation is described in more detail here:</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html">http://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html</a></p>
</blockquote>
<p>The fork server is an integral aspect of the injected instrumentation and simply stops at the first instrumented function to await commands from afl-fuzz.</p>
<p>With fast targets, the fork server can offer considerable performance gains, usually between 1.5x and 2x. It is also possible to:</p>
<blockquote>
<ul>
<li>Use the fork server in manual (“deferred”) mode, skipping over larger, user-selected chunks of initialization code. It requires very modest code changes to the targeted program, and With some targets, can produce 10x+ performance gains.</li>
<li>Enable “persistent” mode, where a single process is used to try out multiple inputs, greatly limiting the overhead of repetitive fork() calls. This generally requires some code changes to the targeted program, but can improve the performance of fast targets by a factor of 5 or more - approximating the benefits of in-process fuzzing jobs while still maintaining very robust isolation between the fuzzer process and the targeted binary.</li>
</ul>
</blockquote>
<h3 id="0x0A-Parallelization"><a href="#0x0A-Parallelization" class="headerlink" title="0x0A Parallelization"></a>0x0A Parallelization</h3><p>The parallelization mechanism relies on periodically examining the queues produced by independently-running instances on other CPU cores or on remote machines, and then selectively pulling in the test cases that, when tried out locally, produce behaviors not yet seen by the fuzzer at hand.</p>
<p>This allows for extreme flexibility in fuzzer setup, including running synced instances against different parsers of a common data format, often with synergistic effects.</p>
<p>For more information about this design, see <a target="_blank" rel="noopener" href="https://afl-1.readthedocs.io/en/latest/user_guide.html#parallel-fuzzing">Tips for parallel fuzzing</a>.</p>
<h3 id="0x0B-Binary-only-instrumentation"><a href="#0x0B-Binary-only-instrumentation" class="headerlink" title="0x0B Binary-only instrumentation"></a>0x0B Binary-only instrumentation</h3><p>Instrumentation of black-box, binary-only targets is accomplished with the help of a separately-built version of QEMU in “user emulation” mode. This also allows the execution of cross-architecture code - say, ARM binaries on x86.</p>
<p>QEMU uses basic blocks as translation units; the instrumentation is implemented on top of this and uses a model roughly analogous to the compile-time hooks:</p>
<pre><code>if (block_address &gt; elf_text_start &amp;&amp; block_address &lt; elf_text_end) &#123;

  cur_location = (block_address &gt;&gt; 4) ^ (block_address &lt;&lt; 8);
  shared_mem[cur_location ^ prev_location]++;
  prev_location = cur_location &gt;&gt; 1;

&#125;</code></pre>
<p>The shift-and-XOR-based scrambling in the second line is used to mask the effects of instruction alignment.</p>
<p>The start-up of binary translators such as QEMU, DynamoRIO, and PIN is fairly slow; to counter this, the QEMU mode leverages a fork server similar to that used for compiler-instrumented code, effectively spawning copies of an already-initialized process paused at _start.</p>
<p>First-time translation of a new basic block also incurs substantial latency. To eliminate this problem, the AFL fork server is extended by providing a channel between the running emulator and the parent process. The channel is used to notify the parent about the addresses of any newly-encountered blocks and to add them to the translation cache that will be replicated for future child processes.</p>
<p>As a result of these two optimizations, the overhead of the QEMU mode is roughly 2-5x, compared to 100x+ for PIN.</p>
<h3 id="0x0C-Others"><a href="#0x0C-Others" class="headerlink" title="0x0C Others"></a>0x0C Others</h3><h4 id="The-afl-analyze-tool"><a href="#The-afl-analyze-tool" class="headerlink" title="The afl-analyze tool"></a>The afl-analyze tool</h4><p>The file format analyzer is a simple extension of the minimization algorithm discussed earlier on; instead of attempting to remove no-op blocks, the tool performs a series of walking byte flips and then annotates runs of bytes in the input file.</p>
<p>It uses the following classification scheme:</p>
<blockquote>
<ul>
<li>“No-op blocks” - segments where bit flips cause no apparent changes to control flow. Common examples may be comment sections, pixel data within a bitmap file, etc.</li>
<li>“Superficial content” - segments where some, but not all, bitflips produce some control flow changes. Examples may include strings in rich documents (e.g., XML, RTF).</li>
<li>“Critical stream” - a sequence of bytes where all bit flips alter control flow in different but correlated ways. This may be compressed data, non-atomically compared keywords or magic values, etc.</li>
<li>“Suspected length field” - small, atomic integer that, when touched in any way, causes a consistent change to program control flow, suggestive of a failed length check.</li>
<li>“Suspected cksum or magic int” - an integer that behaves similarly to a length field, but has a numerical value that makes the length explanation unlikely. This is suggestive of a checksum or other “magic” integer.</li>
<li>“Suspected checksummed block” - a long block of data where any change always triggers the same new execution path. Likely caused by failing a checksum or a similar integrity check before any subsequent parsing takes place.</li>
<li>“Magic value section” - a generic token where changes cause the type of binary behavior outlined earlier, but that doesn’t meet any of the other criteria. May be an atomically compared keyword or so.</li>
</ul>
</blockquote>
<h2 id="How-to-use"><a href="#How-to-use" class="headerlink" title="How to use?"></a>How to use?</h2><h3 id="The-AFL-approach"><a href="#The-AFL-approach" class="headerlink" title="The AFL approach"></a>The AFL approach</h3><p>American Fuzzy Lop is a brute-force fuzzer coupled with an exceedingly simple but rock-solid instrumentation-guided genetic algorithm. It uses a modified form of edge coverage to effortlessly pick up subtle, local-scale changes to program control flow.</p>
<p>Simplifying a bit, the overall algorithm can be summed up as:</p>
<blockquote>
<ol>
<li>Load user-supplied initial test cases into the queue,</li>
<li>Take next input file from the queue,</li>
<li>Attempt to trim the test case to the smallest size that doesn’t alter the measured behavior of the program,</li>
<li>Repeatedly mutate the file using a balanced and well-researched variety of traditional fuzzing strategies,</li>
<li>If any of the generated mutations resulted in a new state transition recorded by the instrumentation, add mutated output as a new entry in the queue.</li>
<li>Go to 2.</li>
</ol>
</blockquote>
<p>The discovered test cases are also periodically culled to eliminate ones that have been obsoleted by newer, higher-coverage finds; and undergo several other instrumentation-driven effort minimization steps.</p>
<p>As a side result of the fuzzing process, the tool creates a small, self-contained corpus of interesting test cases. These are extremely useful for seeding other, labor- or resource-intensive testing regimes - for example, for stress-testing browsers, office applications, graphics suites, or closed-source tools.</p>
<p>The fuzzer is thoroughly tested to deliver out-of-the-box performance far superior to blind fuzzing or coverage-only tools.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><p>vul.c</p>
<pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span> </span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span> </span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span> </span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span> </span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;signal.h></span> </span>

<span class="token keyword">int</span> <span class="token function">vuln_3</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'A'</span> <span class="token operator">&amp;&amp;</span> len <span class="token operator">==</span> <span class="token number">66</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">raise</span><span class="token punctuation">(</span>SIGSEGV<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'F'</span> <span class="token operator">&amp;&amp;</span> len <span class="token operator">==</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">raise</span><span class="token punctuation">(</span>SIGSEGV<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"it is good!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">gets</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// vul1</span>
    <span class="token function">printf</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// vul2</span>
    <span class="token function">vuln_3</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="Compile-source-code"><a href="#Compile-source-code" class="headerlink" title="Compile source code"></a>Compile source code</h4><pre><code>afl-gcc vul.c -o vul</code></pre>
<h4 id="Test-program"><a href="#Test-program" class="headerlink" title="Test program"></a>Test program</h4><pre><code>afl-showmap -m none -o /dev/null -- ./vul</code></pre>
<p>output:</p>
<pre><code>afl-showmap 2.57b by &lt;lcamtuf@google.com&gt;
[*] Executing &#39;./vul&#39;...

-- Program output begins --
AAAAAAAAAABBBBBBBBBBBBBBBB
AAAAAAAAAABBBBBBBBBBBBBBBBit is good!
-- Program output ends --
[+] Captured 3 tuples in &#39;/dev/null&#39;.</code></pre>
<p>Test two:</p>
<p>Trigger signal raise</p>
<pre><code>[i0gan@arch example_1]$ afl-showmap -m none -o /dev/null -- ./vul
afl-showmap 2.57b by &lt;lcamtuf@google.com&gt;
[*] Executing &#39;./vul&#39;...

-- Program output begins --
Faaaaa
-- Program output ends --

+++ Program killed by signal 11 +++
[+] Captured 5 tuples in &#39;/dev/null&#39;.</code></pre>
<p>Using different input, under normal circumstances, <code>afl-showmap</code> cmd will capture different tuples, which shows that our instrumentation is effective. In addition, the previously mentioned <code>afl-cmin</code> uses this tool to remove duplicate input files.</p>
<h4 id="Close-core-pattern"><a href="#Close-core-pattern" class="headerlink" title="Close  core_pattern"></a>Close  core_pattern</h4><p>Before executing <code>afl-fuzz</code>, if the system is configured to send core dump notification to an external program. As a result, the delay between sending crash information to fuzzer will increase, and the crash may be misreported as timeout, so we have to modify the core_pattern file, run command with root user as follows:</p>
<pre><code>echo core &gt;/proc/sys/kernel/core_pattern</code></pre>
<p>Create a output dir</p>
<pre><code>mkdir out</code></pre>
<h4 id="Starting-fuzz"><a href="#Starting-fuzz" class="headerlink" title="Starting fuzz"></a>Starting fuzz</h4><p>fuzz cmd common format</p>
<pre><code>afl-fuzz -i testcase_dir -o findings_dir /path/to/program [params]</code></pre>
<p>if you use @@, will make params as file content</p>
<pre><code>afl-fuzz -i ./testcases/ -o out ./vul @@</code></pre>
<p>The testcases dir is given by github afl project, you just copy that directory to here</p>
<p>May be  comming some error</p>
<p>Whoops, your system uses on-demand CPU frequency scaling, adjusted<br>   between 1367 and 2050 MHz. Unfortunately, the scaling algorithm in the<br>   kernel is imperfect and can miss the short-lived processes spawned by<br>   afl-fuzz. To keep things moving, run these commands as root: </p>
<pre><code>cd /sys/devices/system/cpu
echo performance | tee cpu*/cpufreq/scaling_governor</code></pre>
<p>output:</p>
<pre><code>[i0gan@arch example_1]$ afl-fuzz -i ./testcases/ -o out ./vul @@
afl-fuzz 2.57b by &lt;lcamtuf@google.com&gt;
[+] You have 8 CPU cores and 1 runnable tasks (utilization: 12%).
[+] Try parallel jobs - see /usr/share/doc/afl/parallel_fuzzing.txt.
[*] Checking CPU core loadout...
[+] Found a free CPU core, binding to #0.
[*] Checking core_pattern...
[*] Checking CPU scaling governor...
[*] Setting up output directories...
[+] Output directory exists but deemed OK to reuse.
[*] Deleting old session data...
[+] Output dir cleanup successful.
[*] Scanning &#39;./testcases/&#39;...
[+] No auto-generated dictionary tokens to reuse.
[*] Creating hard links for all input files...
[*] Validating target binary...
[*] Attempting dry run with &#39;id:000000,orig:README.testcases&#39;...
[*] Spinning up the fork server...
[+] All right - fork server is up.
    len = 828, map size = 4, exec speed = 225 us
[+] All test cases processed.

[+] Here are some useful stats:

    Test case count : 1 favored, 0 variable, 1 total
       Bitmap range : 4 to 4 bits (average: 4.00 bits)
        Exec timing : 225 to 225 us (average: 225 us)

[*] No -t option specified, so I&#39;ll use exec timeout of 20 ms.
[+] All set and ready to roll!</code></pre>
<p>MENU UI</p>
<pre><code>
                         american fuzzy lop 2.57b (vul)

┌─ process timing ─────────────────────────────────────┬─ overall results ─────┐
│        run time : 0 days, 0 hrs, 1 min, 12 sec       │  cycles done : 1628   │
│   last new path : none yet (odd, check syntax!)      │  total paths : 1      │
│ last uniq crash : none seen yet                      │ uniq crashes : 0      │
│  last uniq hang : none seen yet                      │   uniq hangs : 0      │
├─ cycle progress ────────────────────┬─ map coverage ─┴───────────────────────┤
│  now processing : 0 (0.00%)         │    map density : 0.01% / 0.01%         │
│ paths timed out : 0 (0.00%)         │ count coverage : 1.00 bits/tuple       │
├─ stage progress ────────────────────┼─ findings in depth ────────────────────┤
│  now trying : havoc                 │ favored paths : 1 (100.00%)            │
│ stage execs : 102/256 (39.84%)      │  new edges on : 1 (100.00%)            │
│ total execs : 418k                  │ total crashes : 0 (0 unique)           │
│  exec speed : 5799/sec              │  total tmouts : 0 (0 unique)           │
├─ fuzzing strategy yields ───────────┴───────────────┬─ path geometry ────────┤
│   bit flips : 0/32, 0/31, 0/29                      │    levels : 1          │
│  byte flips : 0/4, 0/3, 0/1                         │   pending : 0          │
│ arithmetics : 0/224, 0/0, 0/0                       │  pend fav : 0          │
│  known ints : 0/24, 0/84, 0/44                      │ own finds : 0          │
│  dictionary : 0/0, 0/0, 0/0                         │  imported : n/a        │
│       havoc : 0/417k, 0/0                           │ stability : 100.00%    │
│        trim : 99.52%/16, 0.00%                      ├────────────────────────┘
└─────────────────────────────────────────────────────┘          [cpu000: 44%]</code></pre>
<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><p>This paper will continue to write later.</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">i0gan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://blog.i0gan.cn/2021/03/31/fuzz-afl/">http://blog.i0gan.cn/2021/03/31/fuzz-afl/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/fuzz/">fuzz</a></div><div class="post_share"><div class="social-share" data-image="/img/text_bg.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2021/03/30/v8-01/"><img class="next-cover" src="/img/text_bg.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">V8 EXPLOIT ONE</div></div></a></div></nav></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/header.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">i0gan</div><div class="author-info__description">Even if a man has reached the top, he still needs to improve himself</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">52</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">27</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">22</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/i0gan"><i class="fab fa-github"></i><span>Follow Me</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Binary-fuzzing-way-of-american-fuzzy-lop"><span class="toc-number">1.</span> <span class="toc-text">Binary fuzzing way of american fuzzy lop</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Intro"><span class="toc-number">1.1.</span> <span class="toc-text">Intro</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#What-is-AFL-%C2%B6"><span class="toc-number">1.1.1.</span> <span class="toc-text">What is AFL?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#How-to-install-env"><span class="toc-number">1.2.</span> <span class="toc-text">How to install env</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Method-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">Method 1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Method-2"><span class="toc-number">1.2.2.</span> <span class="toc-text">Method 2</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#How-it-works"><span class="toc-number">1.3.</span> <span class="toc-text">How it works?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0x00-Technical"><span class="toc-number">1.3.1.</span> <span class="toc-text">0x00 Technical</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x01-Coverage-measurements"><span class="toc-number">1.3.2.</span> <span class="toc-text">0x01 Coverage measurements</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x02-Detecting-new-behaviors"><span class="toc-number">1.3.3.</span> <span class="toc-text">0x02 Detecting new behaviors</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x03-Evolving-the-input-queue"><span class="toc-number">1.3.4.</span> <span class="toc-text">0x03 Evolving the input queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x04-Culling-the-corpus"><span class="toc-number">1.3.5.</span> <span class="toc-text">0x04 Culling the corpus</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x05-Trimming-input-files"><span class="toc-number">1.3.6.</span> <span class="toc-text">0x05 Trimming input files</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x06-Fuzzing-strategies"><span class="toc-number">1.3.7.</span> <span class="toc-text">0x06 Fuzzing strategies</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x07-Dictionaries"><span class="toc-number">1.3.8.</span> <span class="toc-text">0x07 Dictionaries</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x08-De-duping-crashes"><span class="toc-number">1.3.9.</span> <span class="toc-text">0x08 De-duping crashes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Investigating-crashes"><span class="toc-number">1.3.10.</span> <span class="toc-text">Investigating crashes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x09-The-fork-server"><span class="toc-number">1.3.11.</span> <span class="toc-text">0x09 The fork server</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x0A-Parallelization"><span class="toc-number">1.3.12.</span> <span class="toc-text">0x0A Parallelization</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x0B-Binary-only-instrumentation"><span class="toc-number">1.3.13.</span> <span class="toc-text">0x0B Binary-only instrumentation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x0C-Others"><span class="toc-number">1.3.14.</span> <span class="toc-text">0x0C Others</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#The-afl-analyze-tool"><span class="toc-number">1.3.14.1.</span> <span class="toc-text">The afl-analyze tool</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#How-to-use"><span class="toc-number">1.4.</span> <span class="toc-text">How to use?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#The-AFL-approach"><span class="toc-number">1.4.1.</span> <span class="toc-text">The AFL approach</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Example-1"><span class="toc-number">1.4.2.</span> <span class="toc-text">Example 1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Compile-source-code"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">Compile source code</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Test-program"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">Test program</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Close-core-pattern"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">Close  core_pattern</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Starting-fuzz"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">Starting fuzz</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Example-2"><span class="toc-number">1.4.3.</span> <span class="toc-text">Example 2</span></a></li></ol></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/03/31/fuzz-afl/" title="Binary fuzzing way of american fuzzy lop"><img src="/img/text_bg.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Binary fuzzing way of american fuzzy lop"/></a><div class="content"><a class="title" href="/2021/03/31/fuzz-afl/" title="Binary fuzzing way of american fuzzy lop">Binary fuzzing way of american fuzzy lop</a><time datetime="2021-03-31T02:00:43.000Z" title="Created 2021-03-31 10:00:43">2021-03-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/03/30/v8-01/" title="V8 EXPLOIT ONE"><img src="/img/text_bg.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="V8 EXPLOIT ONE"/></a><div class="content"><a class="title" href="/2021/03/30/v8-01/" title="V8 EXPLOIT ONE">V8 EXPLOIT ONE</a><time datetime="2021-03-30T11:28:43.000Z" title="Created 2021-03-30 19:28:43">2021-03-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/03/26/buu-pwn/" title="BUU PWN"><img src="/img/text_bg.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BUU PWN"/></a><div class="content"><a class="title" href="/2021/03/26/buu-pwn/" title="BUU PWN">BUU PWN</a><time datetime="2021-03-26T01:40:43.000Z" title="Created 2021-03-26 09:40:43">2021-03-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/03/26/buu-crypto/" title="BUU CRYPTO"><img src="/img/text_bg.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BUU CRYPTO"/></a><div class="content"><a class="title" href="/2021/03/26/buu-crypto/" title="BUU CRYPTO">BUU CRYPTO</a><time datetime="2021-03-26T00:36:43.000Z" title="Created 2021-03-26 08:36:43">2021-03-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/03/25/lgx-server/" title="LGX SERVER FRAMEWORK INTRO"><img src="/img/text_bg.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LGX SERVER FRAMEWORK INTRO"/></a><div class="content"><a class="title" href="/2021/03/25/lgx-server/" title="LGX SERVER FRAMEWORK INTRO">LGX SERVER FRAMEWORK INTRO</a><time datetime="2021-03-25T14:54:08.000Z" title="Created 2021-03-25 22:54:08">2021-03-25</time></div></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/text_bg.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By i0gan</div><div class="framework-info"></div><div class="icp"><a target="_blank" rel="noopener" href="http://www.beian.gov.cn/"><img class="icp-icon" src="/img/icp.png" alt="ICP"/><span>黔ICP备20006037号</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>